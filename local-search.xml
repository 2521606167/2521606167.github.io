<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>async/await</title>
    <link href="/2022/11/05/async-await/"/>
    <url>/2022/11/05/async-await/</url>
    
    <content type="html"><![CDATA[<h1>文档</h1><ul class="lvl-0"><li class="lvl-2"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function</a></li><li class="lvl-2"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await</a></li></ul><ol><li class="lvl-3">async 函数</li></ol><ul class="lvl-0"><li class="lvl-2"><p>函数的返回值为promise对象</p></li><li class="lvl-2"><p>2.promise对象的结果由async函数执行的返回值决定</p></li></ul><ol start="2"><li class="lvl-3"><p>await 表达式</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>await右侧的表达式一般为promise对象, 但也可以是其它的值</p></li><li class="lvl-2"><p>如果表达式是promise对象, await返回的是promise成功的值</p></li><li class="lvl-2"><p>如果表达式是其它值, 直接将此值作为await的返回值</p></li><li class="lvl-2"><p>await必须写在async函数中, 但async函数中可以没有await</p></li><li class="lvl-2"><p>如果await的promise失败了, 就会抛出异常, 需要通过try…catch捕获处理</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>async/await</category>
      
    </categories>
    
    
    <tags>
      
      <tag>async/await</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise的几个关键问题</title>
    <link href="/2022/11/03/promise%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2022/11/03/promise%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li class="lvl-3"><p>如何改变promise的状态?</p></li></ol><ul class="lvl-0"><li class="lvl-2">resolve(value): 如果当前是pending就会变为resolved</li><li class="lvl-2">reject(reason): 如果当前是pending就会变为rejected</li></ul><p>抛出异常: 如果当前是pending就会变为rejected</p><ol start="2"><li class="lvl-3"><p>一个promise指定多个成功/失败回调函数, 都会调用吗?</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>当promise改变为对应状态时都会调用</p></li></ul><ol start="3"><li class="lvl-3"><p>改变promise状态和指定回调函数谁先谁后?</p><ol><li class="lvl-7">都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</li><li class="lvl-7">如何先改状态再指定回调?</li></ol><ul class="lvl-2"><li class="lvl-6">在执行器中直接调用resolve()/reject()</li><li class="lvl-6">延迟更长时间才调用then()</li></ul><ol start="3"><li class="lvl-7">什么时候才能得到数据?</li></ol><ul class="lvl-2"><li class="lvl-6">如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</li><li class="lvl-7">如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</li></ul></li><li class="lvl-3"><p>promise.then()返回的新promise的结果状态由什么决定?</p><ol><li class="lvl-7"><p>简单表达: 由then()指定的回调函数执行的结果决定</p></li><li class="lvl-7"><p>详细表达:</p><ul class="lvl-4"><li class="lvl-10">如果抛出异常, 新promise变为rejected, reason为抛出的异常</li><li class="lvl-10">如果返回的是非promise的任意值, 新promise变为resolved, value为返回的值</li><li class="lvl-10">如果返回的是另一个新promise, 此promise的结果就会成为新promise的结果</li></ul></li></ol></li><li class="lvl-3"><p>promise如何串连多个操作任务?</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>promise的then()返回一个新的promise, 可以开成then()的链式调用</p></li><li class="lvl-2"><p>通过then的链式调用串连多个同步/异步任务</p></li></ul><ol start="6"><li class="lvl-3"><p>promise异常传透?</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>当使用promise的then链式调用时, 可以在最后指定失败的回调, 前面任何操作出了异常, 都会传到最后失败的回调中处理</p></li></ul><ol start="7"><li class="lvl-3"><p>中断promise链?</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数</p></li><li class="lvl-2"><p>办法: 在回调函数中返回一个pendding状态的promise对象</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用Promise?</title>
    <link href="/2022/11/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Promise/"/>
    <url>/2022/11/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Promise/</url>
    
    <content type="html"><![CDATA[<h1>API</h1><ol><li class="lvl-3">Promise构造函数: Promise (excutor) {}</li></ol><ul class="lvl-0"><li class="lvl-2">executor函数:  执行器(resolve, reject) =&gt; {}</li><li class="lvl-2">resolve函数: 内部定义成功时调用的函数value =&gt; {}</li><li class="lvl-2">reject函数: 内部定义失败时调用的函数reason =&gt; {}<br>说明: executor会在Promise内部立即同步调用,异步操作在执行器中执行</li></ul><ol start="2"><li class="lvl-3">Promise.prototype.then方法: (onResolved, onRejected) =&gt; {}</li></ol><ul class="lvl-0"><li class="lvl-2"><p>onResolved函数: 成功的回调函数(value) =&gt; {}</p></li><li class="lvl-2"><p>onRejected函数: 失败的回调函数(reason) =&gt; {}<br>说明: 指定用于得到成功value的成功回调和用于得到失败reason的失败回调</p></li></ul><ol start="3"><li class="lvl-3"><p>Promise.prototype.catch方法: (onRejected) =&gt; {}</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>onRejected函数: 失败的回调函数(reason) =&gt; {}<br>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p></li></ul><ol start="4"><li class="lvl-3"><p>Promise.resolve方法: (value) =&gt; {}</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>value: 成功的数据或promise对象说明: 返回一个成功/失败的promise对象</p></li></ul><ol start="5"><li class="lvl-3"><p>Promise.reject方法: (reason) =&gt; {}</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>reason: 失败的原因说明: 返回一个失败的promise对象</p></li></ul><ol start="6"><li class="lvl-3"><p>Promise.all方法: (promises) =&gt; {}</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>promises: 包含n个promise的数组说明: 返回一个新的promise, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败</p></li></ul><ol start="7"><li class="lvl-3"><p>Promise.race方法: (promises) =&gt; {}</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>promises: 包含n个promise的数组说明: 返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要用Promise?</title>
    <link href="/2022/11/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Promise/"/>
    <url>/2022/11/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Promise/</url>
    
    <content type="html"><![CDATA[<h1>指定回调函数的方式更加灵活</h1><ol><li class="lvl-3">旧的: 必须在启动异步任务前指定</li><li class="lvl-3">promise: 启动异步任务=&gt; 返回promie对象=&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定/多个)</li></ol><h1>支持链式调用, 可以解决回调地狱问题</h1><ol><li class="lvl-3"><p>什么是回调地狱?<br>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p></li><li class="lvl-3"><p>回调地狱的缺点?</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>不便于阅读</p></li><li class="lvl-2"><p>不便于异常处理</p></li></ul><ol start="3"><li class="lvl-3"><p>解决方案?<br>promise链式调用</p></li><li class="lvl-3"><p>终极解决方案?<br>async/await</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise基本运行流程</title>
    <link href="/2022/11/03/promise%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/11/03/promise%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/promise.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise 的状态改变</title>
    <link href="/2022/11/02/promise-%E7%9A%84%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98/"/>
    <url>/2022/11/02/promise-%E7%9A%84%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>pending(等待) 变为 resolved（成功状态）</p></li><li class="lvl-2"><p>pending(等待) 变为 rejected（失败状态）</p></li></ul><p>说明: 只有这 2 种, 且一个 promise 对象只能改变一次无论变为成功还是失败, 都会有一个结果数据成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</p>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise 是什么?</title>
    <link href="/2022/11/02/Promise-%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2022/11/02/Promise-%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1>抽象表达</h1><ul class="lvl-0"><li class="lvl-2">Promise 是一门新的技术（Es6规范）</li><li class="lvl-2">Promise 是JS中进行异步编程的新解决方案（旧方案是使用回调函数）</li></ul><h1>具体表达</h1><ul class="lvl-0"><li class="lvl-2"><p>从语法来说：Promise是一个构造函数</p></li><li class="lvl-2"><p>从功能上来说：Promise 对象用来封装一个异步操作并可以获取其成功/<br>失败的结果值</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS常见的错误类型及错误处理</title>
    <link href="/2022/11/02/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/11/02/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1>错误的类型</h1><ul class="lvl-0"><li class="lvl-2">Error: 所有错误的父类型</li><li class="lvl-2">ReferenceError: 引用的变量不存在</li><li class="lvl-2">TypeError: 数据类型不正确的错误</li><li class="lvl-2">RangeError: 数据值不在其允许的范围内</li><li class="lvl-2">SyntaxError: 语法错误</li></ul><h1>错误处理</h1><ul class="lvl-0"><li class="lvl-2"><p>捕获错误：try…catch…</p></li><li class="lvl-2"><p>抛出错误：throw error</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是回调函数？</title>
    <link href="/2022/10/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F/"/>
    <url>/2022/10/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1>什么是回调函数？</h1><ul class="lvl-0"><li class="lvl-2">自己定义的</li><li class="lvl-2">没有调用</li><li class="lvl-2">最终却执行了</li></ul><h1>常见的回调函数</h1><ul class="lvl-0"><li class="lvl-2"><p>dom事件回调函数</p></li><li class="lvl-2"><p>定时器回调函数</p></li><li class="lvl-2"><p>ajax请求</p></li><li class="lvl-2"><p>生命周期回调函数</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造函数</title>
    <link href="/2022/10/27/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/27/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>构造函数是专门用来创建对象的函数</p><ul class="lvl-2"><li class="lvl-6">一个构造函数我们也可以称为一个类</li><li class="lvl-6">通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例</li><li class="lvl-6">通过同一个构造函数创建的对象，我们称为一类对象</li><li class="lvl-6">构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数如果使用new来调用，则它就是一个构造函数</li></ul></li><li class="lvl-2"><p>构造函数的执行流程：</p><ul class="lvl-2"><li class="lvl-6">创建一个新的对象</li><li class="lvl-6">将新的对象作为函数的上下文对象（this）</li><li class="lvl-6">执行函数中的代码</li><li class="lvl-6">将新建的对象返回</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this（上下文对象）</title>
    <link href="/2022/10/27/this%EF%BC%88%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1%EF%BC%89/"/>
    <url>/2022/10/27/this%EF%BC%88%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。</p></li><li class="lvl-2"><p>this的不同的情况：</p><ol><li class="lvl-7">以函数的形式调用时，this是window</li><li class="lvl-7">以方法的形式调用时，this就是调用方法的对象</li><li class="lvl-7">以构造函数的形式调用时，this就是新创建的对象</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js作用域</title>
    <link href="/2022/10/27/Js%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2022/10/27/Js%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1>概念</h1><p>作用域简单来说就是一个变量的作用范围。</p><h1>在JS中作用域分成两种</h1><ul class="lvl-0"><li class="lvl-2"><p>全局作用域</p><ul class="lvl-2"><li class="lvl-6">直接在script标签中编写的代码都运行在全局作用域中</li><li class="lvl-6">全局作用域在打开页面时创建，在页面关闭时销毁。</li><li class="lvl-6">全局作用域中有一个全局对象window，window对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。</li><li class="lvl-6">在全局作用域中创建的变量都会作为window对象的属性保存在全局作用域中创建的函数都会作为window对象的方法保存</li><li class="lvl-6">在全局作用域中创建的变量和函数可以在页面的任意位置访问。在函数作用域中也可以访问到全局作用域的变量。</li><li class="lvl-6">尽量不要在全局中创建变量</li></ul></li><li class="lvl-2"><p>函数作用域</p><ul class="lvl-2"><li class="lvl-6">函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。</li><li class="lvl-6">函数作用域在函数执行时创建，在函数执行结束时销毁。</li><li class="lvl-6">在函数作用域中创建的变量，不能在全局中访问。</li><li class="lvl-6">当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，如果找到了则使用，找不到则继续向上找，一直会</li></ul></li><li class="lvl-2"><p>变量的声明提前</p><ul class="lvl-2"><li class="lvl-6">在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。</li><li class="lvl-6">在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用var关键字声明变量，则变量会变成全局变量</li></ul></li><li class="lvl-2"><p>函数的声明提前</p><ul class="lvl-2"><li class="lvl-6">在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性</li><li class="lvl-6">在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象与函数</title>
    <link href="/2022/10/27/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/27/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1>对象（Object）</h1><ul class="lvl-0"><li class="lvl-2"><p>对象是JS中的引用数据类型</p></li><li class="lvl-2"><p>对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性</p></li><li class="lvl-2"><p>使用typeof检查一个对象时，会返回object</p></li><li class="lvl-2"><p>创建对象</p><ul class="lvl-2"><li class="lvl-6">方式一：<ul class="lvl-4"><li class="lvl-10">var obj = new Object();</li></ul></li><li class="lvl-6">方式二：<ul class="lvl-4"><li class="lvl-10">var obj = {};</li></ul></li></ul></li><li class="lvl-2"><p>向对象中添加属性</p><ul class="lvl-2"><li class="lvl-6"><p>语法：</p><ul class="lvl-4"><li class="lvl-10"><p>对象.属性名 = 属性值;</p></li><li class="lvl-10"><p>对象[“属性名”] = 属性值;</p></li><li class="lvl-10"><p>对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。</p></li><li class="lvl-10"><p>属性值也可以任意的数据类型。</p></li></ul></li><li class="lvl-6"><p>读取对象中的属性</p><ul class="lvl-4"><li class="lvl-10">语法：对象.属性名对象[“属性名”]</li><li class="lvl-10">如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined</li></ul></li><li class="lvl-6"><p>删除对象中的属性</p><ul class="lvl-4"><li class="lvl-10">语法：<br>delete 对象.属性名<br>delete 对象[“属性名”]</li></ul></li><li class="lvl-6"><p>使用in检查对象中是否含有指定属性</p><ul class="lvl-4"><li class="lvl-10">语法：“属性名” in 对象<ul class="lvl-6"><li class="lvl-14">如果在对象中含有该属性，则返回true<br>如果没有则返回false</li></ul></li></ul></li><li class="lvl-6"><p>使用对象字面量，在创建对象时直接向对象中添加属性语法：<br>var obj = {<br>属性名:属性值,<br>属性名:属性值,<br>属性名:属性值,<br>属性名:属性值<br>}</p></li><li class="lvl-6"><p>基本数据类型和引用数据类型</p><ul class="lvl-4"><li class="lvl-10">基本数据类型<br>String Number Boolean Null Undefined</li><li class="lvl-10">引用数据类型<br>Object</li><li class="lvl-10">基本数据类型的数据，变量是直接保存的它的值。变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。</li><li class="lvl-10">引用数据类型的数据，变量是保存的对象的引用（内存地址）。如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。</li><li class="lvl-10">比较两个变量时，对于基本数据类型，比较的就是值，对于引用数据类型比较的是地址，地址相同才相同</li></ul></li></ul></li></ul><h1>函数（Function）</h1><ul class="lvl-0"><li class="lvl-2"><p>函数也是一个对象，也具有普通对象的功能</p></li><li class="lvl-2"><p>函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码</p></li><li class="lvl-2"><p>使用typeof检查一个函数时会返回function</p></li><li class="lvl-2"><p>创建函数</p><ul class="lvl-2"><li class="lvl-6"><p>函数声明<br>function 函数名([形参1,形参2…形参N]){<br>语句…<br>}</p></li><li class="lvl-6"><p>函数表达式<br>var 函数名 = function([形参1,形参2…形参N]){<br>语句…<br>};</p></li><li class="lvl-6"><p>调用函数</p><ul class="lvl-4"><li class="lvl-10">语法：函数对象([实参1,实参2…实参N]);<br>fun() sum() alert() Number() parseInt()</li><li class="lvl-10">当我们调用函数时，函数中封装的代码会按照编写的顺序执行</li></ul></li><li class="lvl-6"><p>形参和实参</p><ul class="lvl-4"><li class="lvl-10"><p>形参：形式参数</p><ul class="lvl-6"><li class="lvl-14">定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开定义形参就相当于在函数内声明了对应的变量但是并不赋值，形参会在调用时才赋值。</li></ul></li><li class="lvl-10"><p>实参：实际参数</p><ul class="lvl-6"><li class="lvl-14">调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,<br>调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。如果实参的数量大于形参，多余实参将不会赋值，如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>exports 和 moudle exports的使用区别</title>
    <link href="/2022/10/26/exports-%E5%92%8C-moudle-exports%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/10/26/exports-%E5%92%8C-moudle-exports%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>使用require()模块时，得到的永远是moudle.exports 指向的对象。</p></li><li class="lvl-2"><p>为了防止混乱，建议不要再同一模块使用 exports和moudle.exports。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>模块化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模块化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是模块化？</title>
    <link href="/2022/10/26/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F/"/>
    <url>/2022/10/26/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1>概念</h1><ul class="lvl-0"><li class="lvl-2">模块化就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。</li></ul><h1>好处</h1><ul class="lvl-0"><li class="lvl-2"><p>提高了代码的复用性。</p></li><li class="lvl-2"><p>提高了代码的可维护性。</p></li><li class="lvl-2"><p>可以实现按需加载。</p></li></ul><h1>模块化规范的好处</h1><p>大家都遵守规范写代码，降低沟通成本，方便各个模块之间 的相互调用。</p>]]></content>
    
    
    <categories>
      
      <category>模块化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模块化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typeof 与 instanceof 区别?</title>
    <link href="/2022/10/26/typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/10/26/typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1>一、typeof</h1><ul class="lvl-0"><li class="lvl-3"><code>typeof</code> 操作符返回一个字符串，表示未经计算的操作数的类型</li></ul>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>使用方法<br>typeof operand<br>typeof(operand)<br><br><br>typeof <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;string&#x27;</span><br>typeof undefined <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;undefined&#x27;</span><br>typeof true <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;boolean&#x27;</span><br>typeof Symbol() <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;symbol&#x27;</span><br>typeof null <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span><br>typeof [] <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span><br>typeof &#123;&#125; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span><br>typeof console <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span><br>typeof console.log <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;function&#x27;</span><br></code></pre></td></tr></table></figure><h1>二、instanceof</h1><ul class="lvl-0"><li class="lvl-3"><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p></li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">object</span> instanceof <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">object</span>为实例对象，<span class="hljs-title">constructor</span>为构造函数</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-3"><p>构造函数通过<code>new</code>可以实例对象，<code>instanceof</code>能判断这个对象是否是之前那个构造函数生成的对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义构建函数</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Car</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">let</span> benz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>()<br>benz <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Car</span> <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>)<br>car <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span> <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;xxx&#x27;</span><br>str <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h1>三、区别</h1><ul class="lvl-0"><li class="lvl-2"><p><code>typeof</code>会返回一个变量的基本类型，<code>instanceof</code>返回的是一个布尔值</p></li><li class="lvl-2"><p><code>instanceof</code> 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</p></li><li class="lvl-2"><p>而<code>typeof</code> 也存在弊端，它虽然可以判断基础数据类型（<code>null</code> 除外），但是引用数据类型中，除了<code>function</code> 类型以外，其他的也无法判断</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python常用的值类型</title>
    <link href="/2022/10/25/python%E5%B8%B8%E7%94%A8%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/10/25/python%E5%B8%B8%E7%94%A8%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>数字(Number)</p></li><li class="lvl-2"><p>字符串(String)</p></li><li class="lvl-2"><p>列表(List) 有序的可变序列</p></li><li class="lvl-2"><p>元组(Tuple) 有序的不可变序列</p></li><li class="lvl-2"><p>集合(Set) 无序的不重复集合</p></li><li class="lvl-2"><p>字典(Dictionary)  无序Key-Value集合</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是事件委托？</title>
    <link href="/2022/10/24/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%9F/"/>
    <url>/2022/10/24/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>当子元素都需要绑定相同事件时，可以将事件绑在父元素上，优点有：</p><ul class="lvl-0"><li class="lvl-2">绑定在父元素，则只需绑定一次，节省性能</li><li class="lvl-2">后续新增的子元素也可以触发父元素绑定的事件</li></ul><p><img src="/images/13.webp" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的事件流模型有哪些？</title>
    <link href="/2022/10/24/JavaScript%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <url>/2022/10/24/JavaScript%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>事件冒泡：由最具体的元素接收，并往上传播</p></li><li class="lvl-2"><p>事件捕获：由最不具体的元素接收，并往下传播</p></li><li class="lvl-2"><p>DOM事件流：事件捕获 -&gt; 目标阶段 -&gt; 事件冒泡</p></li></ul><p><img src="/images/12.webp" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优美语句摘抄4</title>
    <link href="/2022/10/23/%E4%BC%98%E7%BE%8E%E8%AF%AD%E5%8F%A5%E6%91%98%E6%8A%844/"/>
    <url>/2022/10/23/%E4%BC%98%E7%BE%8E%E8%AF%AD%E5%8F%A5%E6%91%98%E6%8A%844/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>从此山水不相逢 莫道彼此长和端。</p></li><li class="lvl-2"><p>早知如此绊人心 何如当初莫相识。</p></li><li class="lvl-2"><p>我是檐上三寸雪 你是人间惊鸿客。</p></li><li class="lvl-2"><p>能当面指出你问题的人，都是好朋友，背后说你坏话的，才是刀刀见血。</p></li><li class="lvl-2"><p>时间长了，你以为有些人变了，其实，不是她变了，只是她把面具摘了。</p></li><li class="lvl-2"><p>爱笑的人运气不会差，因为运气差的人，根本笑不出来。</p></li><li class="lvl-2"><p>我删了一个微信好友，内存腾出来5个G。</p></li><li class="lvl-2"><p>最信任的人，教会你不要相信任何人。</p></li><li class="lvl-2"><p>不要把自己的伤口揭给别人看，这世界上多的不是医生，而是撒盐的人。</p></li><li class="lvl-2"><p>无端坠入凡尘梦 惹却三千烦恼丝。</p></li></ul><p><img src="/images/13.webp" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>优美语句摘抄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优美语句摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue2响应式原理</title>
    <link href="/2022/10/22/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2022/10/22/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1>一、数组</h1><h2 id="1-1-不能监听的情况">1.1 不能监听的情况</h2><ol><li class="lvl-3"><p>直接通过下表赋值 arr[i] = value</p></li><li class="lvl-3"><p>直接修改数组长度 arr.length = newLen</p></li></ol><h2 id="1-2-替代做法">1.2 替代做法</h2><ol><li class="lvl-4"><p>修改值</p></li></ol>   <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Vue.<span class="hljs-keyword">set</span>(arr, index, <span class="hljs-keyword">new</span><span class="hljs-type">value</span>)<br>vm.$<span class="hljs-keyword">set</span>(arr, index, <span class="hljs-keyword">new</span><span class="hljs-type">value</span>)<br>arr.splice(index, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span><span class="hljs-type">value</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li class="lvl-4"><p>修改数组长度</p></li></ol>   <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">arr.splice(<span class="hljs-keyword">new</span><span class="hljs-type">Len</span>) <br></code></pre></td></tr></table></figure><pre><code class="hljs">调用数组的pop、push、shift、unshift、splice、sort、reverse等方法时是可以监听到数组的变化的 </code></pre><h1>二. 对象</h1><h2 id="2-1-不能监听的情况">2.1 不能监听的情况</h2><p>属性的新增和删除</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">obj.<span class="hljs-keyword">new</span><span class="hljs-type">key</span>=<span class="hljs-keyword">new</span><span class="hljs-type">value</span><br>delete obj.key<br></code></pre></td></tr></table></figure><h2 id="2-2-替代做法">2.2 替代做法</h2><p>$$<br>// 新增<br>Vue.set(obj, newkey, newvalue)<br>vm.$set(obj, newkey, newvalue)<br>obj = Object.assign({}, obj, {newkey1: newvalue1, newkey2: newvalue2})<br>// 删除<br>Vue.delete(obj, key)<br>vm.$delete(obj, key)<br>$$</p><h1>三、分析 vue 2 无法监听数组和对象的这些变化的原因</h1><p>首先，vue2是通过Object.defineProperty(obj, key, value)这种方式监听数据的</p><h2 id="3-1-对于数组">3.1 对于数组</h2><p>Object.defineProperty()是可以对数组实现监听操作的，但是vue并没有实现这个功能，因为数组长度不定而且数据可能会很多，如果对每一个数据都实现监听，性能代价太大</p><p>但是注意：数组中的元素是引用类型时是会被监听的</p><h2 id="3-2-对象">3.2 对象</h2><p>Object.defineProperty()针对的是对象的某个属性，而且这个操作在vue的初始化阶段就完成了，所以新增的属性无法监听，通过set方法新增对象就相当于初始化阶段的数据响应式处理</p>]]></content>
    
    
    <categories>
      
      <category>Vue2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型和原型链</title>
    <link href="/2022/10/22/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2022/10/22/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>原型可以解决什么问题？</br><span>对象共享属性和共享方法</span></p></li><li class="lvl-2"><p>谁有原型？</br>函数拥有：prototype<br>对象拥有：<em>proto</em></p></li><li class="lvl-2"><p>对象查找属性或者方法的顺序</br>先在对象本身查找–》构造函数中查找–》对象的原型–》构造函数的原型中–》当前原型的原型</p></li><li class="lvl-2"><p>原型链</br>是什么？  就是把原型串联起来原型链的最顶端是 null</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>null，undefined的区别？</title>
    <link href="/2022/10/22/null%EF%BC%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2022/10/22/null%EF%BC%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>作者在设计null时借鉴了java的语言</p></li><li class="lvl-2"><p>null会被隐式转换为0，不容易发现错误</p></li><li class="lvl-2"><p>先有null和undefined，出来undefined是为了填补之前的坑</p></li><li class="lvl-2"><p>具体区别：null是一个表示“无”的对象，转为数值时为0；undefined表示声明的变量未初始化，转为数值是为NaN。</p></li></ul><p><img src="/images/10.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据类型的检测方法有哪些？</title>
    <link href="/2022/10/21/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <url>/2022/10/21/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>typeof 1 //number</p></li><li class="lvl-2"><p>instanceof Number //false,返回布尔值</p></li><li class="lvl-2"><p>Object.prototype.toString.call(1) //[object Number]</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数据类型有哪些？两种类型的区别？</title>
    <link href="/2022/10/21/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2022/10/21/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>基本数据类型：字符串（String）、数字(Number)、布尔(Boolean)、空值（Null）、未声明（Undefined）、Symbol(注意：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。)</p></li><li class="lvl-2"><p>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</p></li><li class="lvl-2"><p>区别：两者的存放地址不同</p></li></ul><p>基本数据类型存放在栈中，占用内存小，空间固定，且经常被使用。</p><p>引用数据类型存放在堆中，占用内存大，空间不固定；引用数据类型在栈中存放指针。指针指向堆中该实体的起始地址。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扫毒2</title>
    <link href="/2022/10/21/%E8%A7%86%E9%A2%911/"/>
    <url>/2022/10/21/%E8%A7%86%E9%A2%911/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>简介：毒品市场维持四分天下的格局已久，但自从地藏与墨西哥大毒枭跨境合作扩展势力，再加上一连串黑吃黑的动作，毒界变得风声鹤唳。另一方面，因儿时亲眼目睹父亲被毒品所毁而嫉毒如仇的慈善家兼金融巨子余顺天，正悬赏一亿歼灭香港最大毒贩，此举在社会上引起轩然大波。警员林正风本致力搜证拘捕地藏，毒贩却因巨额悬赏导致人身安全受威胁，他在执行保护毒贩的任务时深感无奈，但又被余顺天的出价所诱惑，陷入黑白正邪的心理挣扎。原来，余顺天和地藏有不可告人的同门关系，一场天地对决一触即发。</p></li></ul><iframe src="https://open.iqiyi.com/developer/player_js/coopPlayerIndex.html?vid=ee4a2ad3efd5747eff591e71947b0eda&tvId=1009276800&accessToken=2.ef9c39d6c7f1d5b44768e38e5243157d&appKey=8c634248790d4343bcae1f66129c1010&appId=1368&height=100%&width=100%" frameborder="0" allowfullscreen="true" width="100%" height="450"></iframe>]]></content>
    
    
    <categories>
      
      <category>电影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优美语句摘抄3</title>
    <link href="/2022/10/21/%E4%BC%98%E7%BE%8E%E8%AF%AD%E5%8F%A5%E6%91%98%E6%8A%843/"/>
    <url>/2022/10/21/%E4%BC%98%E7%BE%8E%E8%AF%AD%E5%8F%A5%E6%91%98%E6%8A%843/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p><span style="line-height:40px">终是庄周梦了蝶，你是恩赐亦是劫！</span></p></li><li class="lvl-2"><p><span style="line-height:40px">冬雪将至，共饮此杯！</span></p></li><li class="lvl-2"><p><span style="line-height:40px">南风知我意，吹梦到西洲。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">或许短暂，或许难堪，或许本该这样。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">这个世界什么都有，就是没有如果。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">余生再无倾城色，一草一木皆相思。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">水到绝处是风景，人道绝境是重生。</span></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>优美语句摘抄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优美语句摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优美语句摘抄2</title>
    <link href="/2022/10/21/%E4%BC%98%E7%BE%8E%E8%AF%AD%E5%8F%A5%E6%91%98%E6%8A%842/"/>
    <url>/2022/10/21/%E4%BC%98%E7%BE%8E%E8%AF%AD%E5%8F%A5%E6%91%98%E6%8A%842/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p><span style="line-height:40px">低头要有勇气，抬头要有底气。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">没有收拾残局的能力，就不要放纵自己。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">我这个人走得很慢，但是我从不后退。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">我这个人走得很慢，但是我从不后退。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">我眼里没有你，但余光全是你。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">你曾经不被人所爱，你才会珍惜将来那个爱你的人。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">喜欢一个人，会卑微到尘埃里，然后开出花来。</span></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>优美语句摘抄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优美语句摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优美语句摘抄1</title>
    <link href="/2022/10/21/%E4%BC%98%E7%BE%8E%E8%AF%AD%E5%8F%A5%E6%91%98%E6%8A%84/"/>
    <url>/2022/10/21/%E4%BC%98%E7%BE%8E%E8%AF%AD%E5%8F%A5%E6%91%98%E6%8A%84/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p><span style="line-height:40px">即使失败一百次，也不要后悔一次。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">不要着急，最好的总会在最不经意的时候出现。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">猛兽总是独行的，牛羊才成群结队。 —鲁迅</span></p></li><li class="lvl-2"><p><span style="line-height:40px">不要因为走得太远，忘了我们为什么出发。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">我不在意你曾堕落，我只在意你是否会崛起 。—林肯</span></p></li><li class="lvl-2"><p><span style="line-height:40px">你以为我刀枪不入，我以为你百毒不侵。</span></p></li><li class="lvl-2"><p><span style="line-height:40px">过去属于死神，未来属于自己。</span></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>优美语句摘抄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优美语句摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>img标签的title和alt有什么区别？</title>
    <link href="/2022/10/21/img%E6%A0%87%E7%AD%BE%E7%9A%84title%E5%92%8Calt%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2022/10/21/img%E6%A0%87%E7%AD%BE%E7%9A%84title%E5%92%8Calt%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>title ： 鼠标移入到图片显示的值</p></li><li class="lvl-2"><p>alt   ： 图片无法加载时显示的值</p></li></ul><p><img src="/images/6.jpeg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>title与h1的区别、b与strong的区别、i与em的区别？</title>
    <link href="/2022/10/21/title%E4%B8%8Eh1%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%E4%B8%8Eem%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2022/10/21/title%E4%B8%8Eh1%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%E4%B8%8Eem%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1>title与h1的区别、b与strong的区别、i与em的区别？</h1><h1>title与h1的区别：</h1><ul class="lvl-0"><li class="lvl-2"><p>title他是显示在网页标题上、h1是显示在网页内容上</p></li><li class="lvl-2"><p>在做网站SEO的层面上，title&gt;h1（蜘蛛先爬title）场景：</p></li><li class="lvl-4"><p>网站的logo都是用h1标签包裹的</p></li></ul><h1>b与strong的区别：</h1><p>定义：</p><ul class="lvl-0"><li class="lvl-4"><p>b：实体标签，用来给文字加粗的。</p></li><li class="lvl-4"><p>strong：逻辑标签，用来加强字符语气的。</p></li></ul><hr><p>区别：</p><ul class="lvl-0"><li class="lvl-5"><p>b只是一个加粗标签，没什么特殊含义</p></li><li class="lvl-5"><p>strong也是一个加粗标签，但是有特殊含义，（强调：阅读器、seo）</p></li></ul><h1>i与em的区别：</h1><p>定义：</p><ul class="lvl-0"><li class="lvl-4"><p>i:实体标签，用来做文字倾斜的。</p></li><li class="lvl-4"><p>em：是逻辑标签，用来强调文字内容的</p></li></ul><hr><p>区别：</p><ul class="lvl-0"><li class="lvl-4"><p>i只是一个倾斜标签，没有实际含义。</p></li><li class="lvl-4"><p>em表示标签内字符重要，用以强调的。场景：</p></li><li class="lvl-4"><p>i更多的用在字体图标，em术语上（医药，生物）。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>link 与 @import 的区别</title>
    <link href="/2022/10/21/link-%E4%B8%8E-import-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/10/21/link-%E4%B8%8E-import-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1>link 与 @import 的区别</h1><ol><li class="lvl-3">link 属于 html 标签，而@import 是 css提供</li><li class="lvl-3">页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面加载结束后加载</li><li class="lvl-3">link 方式样式的权重高于@import 的</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行内元素有哪些？块级元素有哪些？ 空(void)元素有哪些？</title>
    <link href="/2022/10/21/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E7%A9%BA-void-%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <url>/2022/10/21/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E7%A9%BA-void-%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1>行内元素有哪些？块级元素有哪些？ 空(void)元素有哪些？</h1><p>行内元素：span、img、input…<br>块级元素：div、footer、header、section、p、h1…h6…<br>空元素：br、hr…</p><p>元素之间的转换问题：<br>display: inline;       把某元素转换成了行内元素===&gt;不独占一行的，并且不能设置宽高<br>display: inline-block; 把某元素转换成了行内块元素===&gt;不独占一行的，可以设置宽高<br>display: block;        把某元素转换成了块元素===&gt;独占一行，并且可以设置宽高</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue2的生命周期</title>
    <link href="/2022/10/21/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/10/21/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1>vue2的生命周期?</h1><h2 id="1、系统自带：">1、系统自带：</h2><p>beforeCreate<br>created<br>beforeMount<br>mounted<br>beforeUpdate<br>updated<br>beforeDestroy<br>destroyed</p><h2 id="2、一旦进入到页面或者组件，会执行哪些生命周期，顺序">2、一旦进入到页面或者组件，会执行哪些生命周期，顺序</h2><p>beforeCreate<br>created<br>beforeMount<br>mounted</p><h2 id="3、在哪个阶段有-el-在哪个阶段有-data">3、在哪个阶段有$el,在哪个阶段有$data</h2><p>created  有data没有el</p><p>mounted 都有</p><h2 id="4、如果加入keep-alive会多两个生命周期">4、如果加入keep-alive会多两个生命周期</h2><p>activated、deactivated</p><h2 id="5、如果加入了keep-alive-第一次进入组件会执行哪些生命周期？">5、如果加入了keep-alive,第一次进入组件会执行哪些生命周期？</h2><p>beforeCreate<br>created<br>beforeMount<br>mounted<br>activated</p><h2 id="6、如果加入了keep-alive-第二次或者第n次进入组件会执行哪些生命周期">6、如果加入了keep-alive,第二次或者第n次进入组件会执行哪些生命周期</h2><p>只执行一个生命周期：activated</p>]]></content>
    
    
    <categories>
      
      <category>Vue2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Html-innerText与innerHTML的区别</title>
    <link href="/2022/10/20/Html/"/>
    <url>/2022/10/20/Html/</url>
    
    <content type="html"><![CDATA[<ol><li class="lvl-3"><p>innerText ：不识别html标签 非标准 去除空格和换行</p></li><li class="lvl-3"><p>innerHTML：识别html标签 w3c标准  保留空格和换行</p></li></ol><p><img src="/images/3.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css-伪元素和伪类的区别总结</title>
    <link href="/2022/10/20/css%E4%BC%AA%E5%85%83%E7%B4%A0-%E4%BC%AA%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/10/20/css%E4%BC%AA%E5%85%83%E7%B4%A0-%E4%BC%AA%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>伪元素本身不存在在DOM文档中，它需要人为的去创建它。且就算你创建了伪元素，它也只是逻辑上存在，实际上也并不存在DOM文档中，也就是说你无法使用JS去获取改变它。</p><p>伪类它存在于DOM文档中，但如果你没有特别的去声明它，你就看不到它。</p><ol><li class="lvl-3"><p>伪元素是创建了一个新元素，而伪类本身就存在只不过不用特别声明</p></li><li class="lvl-3"><p>伪元素使用<code>:</code>或者<code>::</code>声明(前者是css2的声明方式，后者是css3)，而伪类只能使用<code>：</code> (建议在H5中伪元素统一用<code>::</code> 以便区分伪元素和伪类)</p></li><li class="lvl-3"><p>伪元素只能同时使用一个，伪类可以同时使用多个</p></li></ol><p>常见伪元素</p><ul class="lvl-0"><li class="lvl-2"><p>::after (:after)</p></li><li class="lvl-2"><p>::before (:before)</p></li><li class="lvl-2"><p>::cue (:cue)</p></li><li class="lvl-2"><p>::first-letter (:first-letter)</p></li><li class="lvl-2"><p>::first-line (:first-line)</p></li><li class="lvl-2"><p>::selection</p></li><li class="lvl-2"><p>::slotted()</p></li><li class="lvl-2"><p>::spelling-error</p></li></ul><p>常见伪类</p><ul class="lvl-0"><li class="lvl-2"><p>:active</p></li><li class="lvl-2"><p>:disabled</p></li><li class="lvl-2"><p>:first</p></li><li class="lvl-2"><p>:first-child</p></li><li class="lvl-2"><p>:first-of-type</p></li><li class="lvl-2"><p>:hover</p></li><li class="lvl-2"><p>:not()</p></li><li class="lvl-2"><p>:required</p></li></ul><pre><code class="hljs"></code></pre>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css-盒子模型</title>
    <link href="/2022/10/20/css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/10/20/css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1>css盒子模型</h1><ol><li class="lvl-3"><p>W3C盒子（标准盒子模型）由margin，border，padding，content，设置的width height是针对content的</p></li><li class="lvl-3"><p>IE盒子（怪异盒子模型）由margin，border，padding，content构成，但是设置的width height是包括border+padding+content</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="/2022/10/19/hello-world/"/>
    <url>/2022/10/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
